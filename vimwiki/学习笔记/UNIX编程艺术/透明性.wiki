= 透明性 =

%toc

{{{class="brush:text"
    不要让调试工具仅仅成为一种事后追加或者用过就束之高阁的东西。它们是通往
代码的窗口：不要只在窗口凿出粗糙的洞，要修整这些洞并装上窗。如果打算让代码
一直可被维护，就始终必须让光进去。
}}}

== 为透明性和可显性而设计 ==
{{{class="brush:text"
    要为透明性和可显性而设计，就必须运用各种计策来保持代码的简洁，也必须专注
代码同其他人交流的方式。在“这个设计能行吗？“之后要提出的头几个问题就是“别人能
读懂这个设计吗？这个设计优雅吗？”
}}}

=== 透明性之禅 ===
- 要追求代码的透明，最有效的方法很简单，就是`不要在具体操作的代码上叠放太多的抽象层`。
- 禅的一个主要教导是，通常我们都透过源于欲望的偏见和成见的迷雾观察世界。要开悟，我们必须遵循禅的教导，不仅要“去欲望，少依恋”，还要“如实见”——不要让偏见和成见蒙住了眼。

=== 为透明性和可显性而编码 ===
- 思考以下几个问题：
    - 程序调用层次中最大的静态深度是多少？如果大于四，就要当心。
    - 代码是否具有强大、明显的不变性质？
    - 每个API的各个函数调用是否正交？是否存在太多的标志位，使得一个调用完成多个任务？
    - 程序的数据结构或分类和它们所代表的外在实体之间，是否存在清晰的一对一映射？
    - 是否容易找到给定函数的代码部分？不仅单个函数、模块，还有整个代码，需要花多少精力才能读懂？
    - 代码增加了特殊情况还是避免了特殊情况？特殊情况使代码更难理解。
    - 代码中有多少个magic number?

=== 透明性和避免过度保护 ===
{{{class="brush:text"
    程序员经常建造过分精细的抽象城堡，这一倾向的近亲是过度保护底层细节。尽管在程序的正常
操作模式中隐藏这些细节并不是不良做法，但这些细节必须能够找到。隐藏细节和无法访问细节有着
重要区别。
}}}

=== 为可维护性而设计 ===
{{{class="brush:text"
    如果作者以外的其他人能够顺利地理解和修改软件，则这个软件是可维护的。可维护性不仅要求
代码能够运行；还要求代码能够遵循清晰原则，并且和人以及计算机成功沟通。
    Unix程序员学到了一种品性，就是宁愿抛弃、重建代码也不愿修补那些蹩脚的代码。
    如果希望代码成为活代码，则有效的时间花费之一就是投入精力使代码具备可维护性。
}}}
