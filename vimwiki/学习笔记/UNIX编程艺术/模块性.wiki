= 模块性 =

%toc

{{{class="brush:text"
    模块化原则在这里展开来说就是：要编写复杂软件又不至于一败涂地的唯一方法，
就是用定义清晰的接口把若干简单模块组合起来，如此一来，多数问题只会出现在局部，
那么还有希望对局部进行改进和优化，而不至于牵动全身。
}}}

== 封装和最佳模块大小 ==
{{{class="brush:text"
    模块化代码的首要特质就是封装。封装良好的模块不会过多向外部披露自身的细节，不会
直接调用其他模块的实现代码，也不会胡乱共享全局数据。模块之间通过应用程序编程接口（API）
——一组严密、定义良好的程序调用和数据结构来通信。
}}}

== 紧凑性和正交正性 ==

- 紧凑性
{{{class="brush:text"
    紧凑性就是一个设计是否能够装进人脑中的特性。测试软件紧凑性的一个很实用的方法是：
有经验的用户通常需要操作手册吗？如果不需要，那么这个设计就是紧凑的。
}}}

- 正交性
{{{class="brush:text"
    正交性是有助于使复杂设计也能紧凑的最重要的特性之一。在纯粹的正交设计中，任何操作均
无副作用；每个动作只改变一件事，不会影响其他。无论你控制的什么系统，改变每个属性的方法
有且只有一个。
}}}

- SPOT原则
{{{class="brush:text"
    SPOT（Single Point of Truth）意思是说：任何一个知识点在系统内都应当有一个唯一、
明确、权威的表述。
}}}

- 紧凑性和强单一中心
{{{class="brush:text"
    要提高设计的紧凑性，有一个精妙但强大的方法，就是围绕“解决一个定义明确的问题”的强核心算法
组织设计，避免臆断臆和臆捏造。
}}}

== 软件是多层的 ==

- 自顶向下和自底向上
{{{class="brush:text"
    一个方向是自底向上，从具体到抽象——从问题域中你确定要进行的具体操作开始，向上进行。
例如，如果为一个磁盘驱动器设计固件，一些底层原语可能包括“磁头移至物理块”、“读物理块”、
“写物理块”、“开关驱动器LED”等。
    另一个方向是自顶向下，从抽象到具体——从最高层面描述整个项目的规格说明或应用逻辑开始，
向下进行，直到各个具体操作。这样，如果要为一个能处理不同介质的大容量存储器设计软件，可以
从抽象的操作开始，如“移到逻辑块”、“读逻辑块”、“写逻辑块”、“开关状态指示器”等。
    因此实际代码往往是自顶向下和自底向上的综合产物。同一个项目中经常同时兼有自顶向下和
自底向上的代码。这就导致了“胶合胶层”的出现。
}}}

- 胶合层
{{{class="brush:text"
    Unix程序员几十年的教训之一就是：胶合层是个挺讨厌的东西，必须尽可能薄。胶合层用来将东西
粘在一起，但不应该隐藏各层的裂痕和不平整。
}}}

- 程序库
{{{class="brush:text"
    Unix编程风格强调模块性和定义良好的API，它所产生的影响之一就是：强烈倾向于把程序分解成由
胶合层连接的库集合，特别是共享库。
}}}

== Unix和面向对象语言 ==
    _如果你知道自己在做什么，三层就足够了；但是如果你不知道自己在做什么，十七层也没用。_

== 模块式编码 ==
=== 以下问题有助于提高代码的模块性 ===
- 有多少全局变量？全局变量对模块化是毒药。
- 单个模块的大小是否在Hatton的“最佳范围”内？（400-800行之间）
- 模块内的单个函数是不是太大了？
- 好的API应该是定义清楚的，不用看具体实现就能够理解的。
- API的入口点是不是超过七个？有没有哪个类有七个以上的方法？数据结构的成员是不是超过七个？
- 模块复杂性往往和入口点数量的平方成正比。

